## OAuth2

Oauth2 is an advanced version of Token based authorization. Ex: we use Facebook/Google/Twitter to sign-in to an application.

### How does it work?

- User sends an authentication request to say Google/Facebook.
- On finding that the user has an account on Google, the Google server responds with an authorization grant.
- The requesting application uses the authorization grant access specific information.
- On gaining the permission, the app generates an access token.
- The client then uses the access token to access a resource.

### Advantages

- Delegated Access: OAuth 2.0 allows resource owners to delegate access to their resources, ensuring that clients have limited access scopes based on the granted permissions.
- Scalability: OAuth 2.0 is highly scalable due to its token-based nature, making it suitable for large distributed systems and microservices architectures.
- Security: OAuth 2.0 provides a secure way to authenticate users and delegate access without sharing the actual user credentials (username and password).
- Standardization: OAuth 2.0 is a widely accepted standard adopted by many companies and services, promoting interoperability.
- Flexibility: OAuth 2.0 supports multiple flows (grant types) to cater to various client types and scenarios, such as web applications, mobile apps, and single-page applications (SPAs).
- Revocable Access: Tokens issued by OAuth 2.0 can be revoked, allowing resource owners to easily remove access from clients.
- Support for Multiple Use Cases: OAuth 2.0 is versatile and can be used for various use cases, including authentication, authorization, and single sign-on (SSO).
- Third-party Application Access: OAuth 2.0 facilitates third-party application access to user resources without exposing user credentials, promoting the development of secure third-party applications and integrations.

### Disadvantages

- Complexity: Implementing OAuth 2.0 can be complex due to its multiple flows, each catering to different use cases and requiring specific implementations.
- Phishing Vulnerability: Since OAuth 2.0 relies on redirection flows, it can be susceptible to phishing attacks where attackers can mimic the OAuth 2.0 process to capture user credentials.
- Access Token Exposure: Access tokens may be exposed to the client-side, especially in implicit flows used by single-page applications, making them vulnerable to theft.
- Dependency on SSL/TLS: OAuth 2.0 heavily relies on SSL/TLS for security. If SSL/TLS is compromised or poorly implemented, the OAuth 2.0 process can be vulnerable.
- Lack of Built-in Signature Mechanism: OAuth 2.0 does not have a built-in signature mechanism, relying on bearer tokens, which means that anyone who possesses the token can access the resources.
- Limited Guidance on Token Handling: OAuth 2.0 specification provides limited guidance on how to securely handle and store tokens, leaving it up to the implementers.
- Revocation Overhead: Managing and implementing token revocation can add overhead and complexity to the system.
- Potential for Insecure Implementation: Due to its flexibility and multiple flows, there’s a risk of insecure implementations if developers do not fully understand OAuth 2.0 concepts and best practices.
- Mobile Devices Challenges: Implementing OAuth 2.0 securely on mobile devices can be challenging due to the inherent insecurity of these devices and the potential exposure of tokens.

### Types of attacks:

- #### Phishing Attacks

  Attackers create malicious sites or applications that mimic the OAuth 2.0 authorization process, tricking users into revealing their credentials.

  ##### Mechanism

  The attacker sets up a fake OAuth 2.0 authorization server or client application. Users are tricked into initiating the OAuth 2.0 flow, and their credentials are captured by the attacker.

  _Example:_ A user is directed to a malicious application that requests access to their Google account. The user is redirected to a fake Google login page, where their credentials are captured when they attempt to log in.

- #### Token Hijacking

  Attackers steal OAuth 2.0 tokens, gaining unauthorized access to protected resources.

  ##### Mechanism

  Tokens can be intercepted during transmission or stolen from insecure storage or logs.

  _Example:_ An attacker exploits a vulnerability in a mobile application, capturing tokens stored insecurely on the device.

- #### Redirect URI Manipulation

  Attackers manipulate the redirect URI in the authorization request to capture authorization codes.

  ##### Mechanism

  The attacker modifies the redirect URI to point to a malicious site, capturing authorization codes or tokens sent as query parameters.

  _Example:_ An attacker modifies the redirect URI in a client’s authorization request, capturing the authorization code when the user completes the login process.

- #### Cross-Site Request Forgery (CSRF) in OAuth 2.0

  Attackers trick users into executing unwanted actions on a web application in which they're authenticated using OAuth 2.0.

  ##### Mechanism

  The attacker creates malicious links or embeds scripts in webpages to initiate unauthorized OAuth 2.0 authorization requests.

  _Example:_ A user authenticated in a web application is tricked into clicking a link that initiates an unauthorized OAuth 2.0 flow, potentially granting access to a malicious application.

- #### Code Interception Attack

  Attackers intercept authorization codes in the OAuth 2.0 authorization code flow.

  ##### Mechanism

  The attacker intercepts the authorization code by manipulating redirect URIs or through other means, such as network eavesdropping.

  _Example:_ An attacker registers a malicious application with a redirect URI that closely resembles a legitimate application’s URI, capturing authorization codes.

- #### Token Replay Attack

  Attackers reuse tokens to gain unauthorized access to protected resources.

  ##### Mechanism

  Captured tokens are replayed in unauthorized requests to access protected resources.

  _Example:_ An attacker captures a token and uses it to access protected resources or APIs, impersonating the legitimate user.

- #### Insecure Direct Object References (IDOR) in OAuth 2.0

  Attackers access objects that they’re not supposed to by manipulating input or request parameters.

  ##### Mechanism

  The attacker modifies references to gain unauthorized access to other users' resources.

  _Example:_ An attacker modifies the user ID parameter in API requests, accessing another user’s data.

- #### Mix-Up Attack

  Attackers manipulate the OAuth 2.0 flow to confuse the client into using attacker-controlled endpoints.

  ##### Mechanism

  The attacker interferes with the discovery process or manipulates metadata exchange to control parts of the OAuth 2.0 flow.

  _Example:_ During the discovery process, an attacker manipulates metadata to point to malicious authorization or token endpoints.

- #### Client Impersonation

  Attackers impersonate legitimate OAuth 2.0 clients to gain unauthorized access.

  ##### Mechanism

  The attacker registers a malicious client with characteristics that closely mimic a legitimate client.

  _Example:_ An attacker registers a malicious client with a similar name and logo as a popular application, tricking users into granting access.

### Defense against the attacks:
- Use Well-Known Providers: Only use well-known and trusted OAuth 2.0 providers for authentication.
- Secure Transmission: Always use HTTPS to ensure secure transmission of tokens.
- Token Storage: Store tokens securely, avoiding easily accessible places like local storage.
- Strict Redirect URIs: Only allow specific, predefined redirect URIs.
- Validate Redirect URIs: Ensure that the redirect URIs are validated rigorously against a whitelist.
- State Parameter: Use the state parameter to link client sessions with OAuth 2.0 requests.
- Validate State: Validate the state parameter to ensure that the authorization request originated from the client.
- PKCE (Proof Key for Code Exchange): Implement PKCE to protect the authorization code flow, especially for mobile and native applications.
- Token Uniqueness: Ensure that tokens are unique to prevent reuse.
- Token Expiration: Implement short-lived tokens that expire after a brief period.
- Access Control: Implement proper access control mechanisms to ensure users can only access objects they are authorized to access.
- Validate User Input: Validate and sanitize user input to prevent unauthorized object references.
- Metadata Validation: Validate metadata rigorously to ensure it originates from trusted sources.
- Manual Configuration: Consider manual configuration of endpoints and keys to avoid relying on automatic discovery.
- Client Authentication: Implement client authentication to ensure that the client is legitimate.
- Client Secret: Use a client secret or other authentication mechanisms to validate the client’s identity.
